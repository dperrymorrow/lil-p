/*
lil-p
version: 0.1
compiled: 2014-06-23
David Morrow <dperrymorrow@gmail.com>
*/
!function() {
    "use strict";
    Function.prototype.method = function(name, func) {
        return this.prototype[name] ? void 0 : (this.prototype[name] = func, this);
    };
}(), function() {
    "use strict";
    String.method("pluralize", function(value) {
        return value = value || 2, parseInt(value, 10) > 1 ? this + "s" : this;
    }), String.method("contains", function(checkFor) {
        return -1 !== this.indexOf(checkFor.toString());
    }), String.method("singularize", function() {
        return "s" === this.substring(this.length - 1, this.length) ? this.substring(0, this.length - 1) : this;
    }), String.method("safe", function() {
        return this.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    }), String.method("humanize", function() {
        return this.replace(/([a-z])([A-Z])/g, "$1 $2").replace(/[_\-]/g, " ").toLowerCase().trim();
    }), String.method("inject", function(scope) {
        var matches = this.match(/\#\{.+?\}/g), pretified = this, i = 0;
        for (i = 0; i < matches.length; i += 1) {
            var match = matches[i], variable = match.substr(2, match.length - 3);
            pretified = pretified.replace(match, scope[variable]);
        }
        return pretified;
    }), String.method("wordWrap", function(len, chars) {
        var i = 0, z = 0, str = this.toString(), chunks = [], chunk = "";
        for (len = "number" != typeof len ? null : len, chars = "object" != typeof chars ? null : chars, 
        chars = chars || [ "/", "-", " " ], len = len || 25, i = 0; i <= str.length; i += len) chunks.push(str.substring(i, i + len));
        for (i = 0; i < chunks.length; i += 1) {
            for (chunk = chunks[i], z = 0; z <= chars.length; z += 1) chunk = chunk.split(chars[z]).join(chars[z] + "<wbr>");
            chunk.contains("<wbr>") === !1 && i !== chunks.length - 1 && (chunk += "<wbr>"), 
            chunks[i] = chunk;
        }
        return chunks.join("");
    }), String.method("truncate", function(length, append) {
        return append = append || "...", length = length || 10, this.length > length ? this.substring(0, length).trimRight() + append : this;
    }), String.method("trim", function() {
        return this.replace(/^\s+|\s+$/g, "");
    }), String.method("trimLeft", function() {
        return this.replace(/^\s+/, "");
    }), String.method("trimRight", function() {
        return this.replace(/\s+$/, "");
    });
}(), function() {
    "use strict";
    Object.method("keys", function() {
        var keys = [], key = "";
        for (key in this) this.hasOwnProperty(key) && keys.push(key);
        return keys;
    });
}(), function() {
    "use strict";
    Date.timeStampUnits = {
        year: 31536e6,
        month: 2628e6,
        week: 6048e5,
        day: 864e5,
        hour: 36e5,
        minute: 6e4,
        second: 1e3
    }, Date.method("setTimeAgo", function(phrase) {
        var amount, unit, arr = phrase.split(" ");
        if (2 !== arr.length) throw "You must pass in a phrase in '2 Years' format!";
        return amount = parseInt(arr[0], 10), unit = arr[1].toLowerCase().singularize(), 
        this.setTime(this.getTime() - amount * Date.timeStampUnits[unit]), this;
    }), Date.method("distanceInWords", function(from, suffix) {
        var i = 0, diff = 0, unitKeys = Date.timeStampUnits.keys(), parts = {
            nextSmallestUnit: "",
            unit: "",
            wholeUnits: 0,
            remainder: 0,
            str: ""
        };
        if (parts.suffix = suffix || "ago", parts.suffix = parts.suffix.trim(), from = from instanceof Date == !1 ? new Date() : from, 
        diff = Math.abs(from.getTime() - this.getTime()), diff < Date.timeStampUnits.minute) return "less than a minute #{suffix}".inject(parts);
        for (i = 0; i < unitKeys.length; i += 1) {
            if (parts.unit = unitKeys[i], parts.nextSmallestUnit = unitKeys[i + 1], diff > .9 * Date.timeStampUnits[parts.unit] && diff < 1.1 * Date.timeStampUnits[parts.unit]) return "about one #{unit} #{suffix}".inject(parts);
            if (diff >= Date.timeStampUnits[parts.unit]) return parts.wholeUnits = diff / Date.timeStampUnits[parts.unit], 
            parts.remainder = (diff / Date.timeStampUnits[parts.unit] - parts.wholeUnits.toFixed(0)) * Date.timeStampUnits[parts.unit], 
            parts.remainder = Math.round(parts.remainder / Date.timeStampUnits[parts.nextSmallestUnit]), 
            parts.wholeUnits = parts.wholeUnits.toFixed(0), parts.unit = parts.unit.pluralize(parts.wholeUnits), 
            parts.wholeUnits > 0 && (parts.str = "#{wholeUnits} #{unit}".inject(parts)), parts.remainder > 0 && (parts.nextSmallestUnit = parts.nextSmallestUnit.pluralize(parts.remainder), 
            parts.str = "#{str}, #{remainder} #{nextSmallestUnit}".inject(parts)), "#{str} #{suffix}".inject(parts);
        }
    });
}();
//# sourceMappingURL=lil-p.min.js.map